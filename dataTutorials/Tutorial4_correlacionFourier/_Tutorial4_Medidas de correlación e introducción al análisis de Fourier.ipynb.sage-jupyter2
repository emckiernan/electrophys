{"type":"cell","id":"0051cb","pos":23,"input":"### Otra forma de obtener el PSD de una señal es simplemente calcular la transformada de Fourier de la función de autocorrelación de la señal:","cell_type":"markdown"}
{"type":"cell","id":"058066","pos":6,"input":"eeg = np.genfromtxt(\"testdata_eeg\", delimiter=\",\") \nsamp_rate = 256.0\ntiempo = np.arange(0,len(eeg))*(1/samp_rate)\n","cell_type":"code","exec_count":6}
{"type":"cell","id":"06ca70","pos":15,"input":"<a id='fourier'></a>\n## 4. Introducción al análisis de Fourier\n\nEl teorema de representación en series de Fourier es un resultado muy fuerte del análisis de funciones, este teorema nos dice que cualquier función $f(x)$ que  cumplan con ser:\n\n$$\\textbf{1) periódica}$$\n\n$$\\textbf{2) continua}$$ \n\n$$\\textbf{3) suave a tramos}$$,\n\npuede expresarse como una suma de senos y cosenos con amplitudes y frecuencias distintas. Esto se escribe como:\n\n$$ f(x) = \\frac{a_{0}}{2} + {{\\sum_{n=1}^\\infty(a_{n}  cos(\\frac{2\\pi n}{P}x) + b_{n}  sen(\\frac{2\\pi n}{P}x) ) }} $$\n\ndonde $P$ es el periodo de $f(x$) y $a_{n}$, $b_{n}$ son los coeficientes de Fourier que indican la contribución de cada seno y coseno de la serie, estos se obtienen de la siguiente forma:\n\n$$ a_{0} = \\int_{0}^{P} f(x)   dx  $$\n$$ a_{n} = \\int_{0}^{P} f(x) cos(\\frac{2\\pi n}{P}x) dx  $$\n$$ b_{n} = \\int_{0}^{P} f(x) sen(\\frac{2\\pi n}{P}x) dx  $$\n\nEn otras palabras, representar una función como su serie de Fourier es equivalente a encontrar las frecuencias que la componen y determinar qué tanto contribuyen dentro de la función original. Esto hace que el análisis de Fourier sea de las herramientas más ampliamente utilizadas en el análisis y procesamiento de señales.\n\nEs importante recalcar que el análisis de Fourier sólo es adecuado mientras la serie de tiempo analizada cumpla  (al menos de forma aproximada) con las propiedades 1), 2) y 3). De otra forma, los resultados pueden ser engañosos por lo que es recomendable llevar a cabo otros métodos de análisis.","cell_type":"markdown"}
{"type":"cell","id":"0bdd61","pos":19,"input":"fig = plt.figure(figsize=(10, 3), dpi=200)\n\nax = fig.add_subplot(2, 1, 1)\nax.set_xlabel('Tiempo [s]')\nax.set_ylabel('Amplitud [$\\mu$ V]')\nax.set_title('EEG - Dominio del tiempo')\n\n\nax.plot(tiempo,eeg)\n\nax = fig.add_subplot(2, 1, 2)\n\nax.set_xlabel('Frecuencia [Hz]')\nax.set_ylabel('Amplitud [$\\mu$ V]')\nax.set_title('EEG - Dominio de frecuencias')\nax. set_xlim(0,250)\nax.plot(frq)\n\nplt.tight_layout()\n\n","output":{"0":{"name":"stderr","output_type":"stream","text":"/ext/anaconda3/lib/python3.5/site-packages/numpy/core/numeric.py:531: ComplexWarning: Casting complex values to real discards the imaginary part\n  return array(a, dtype, copy=False, order=order)\n"},"1":{"data":{"image/png":"de2e4195abbdfc04185833e61818d9c9b43f0edf"},"output_type":"execute_result","exec_count":12}},"cell_type":"code","exec_count":12}
{"type":"cell","id":"1b2a58","pos":3,"input":"## Tabla de contenidos:\n\n[1. Introducción](#introduction)\n\n[2. Diagrama de Poncairé ](#poncaire)\n\n[3. Función de autocorrelación](#autocorr)\n\n[4. Introducción al análisis de Fourier](#fourier)\n\n[4.1 Transformada de Fourier](#fourier_trans)\n\n[4.2 Densidad del espectro de frecuencias](#psd)","cell_type":"markdown"}
{"type":"cell","id":"292ec4","pos":20,"input":"<a id='psd'></a>\n### 2.2 PSD (Densidad de potencia del espectro de frecuencias)\n\nLa densidad del espectro de frecuencias de una función (*power spectral density* o PSD), es una descripción de cómo se distribuye la energía (potencia) de una señal dentro de los valores de frecuencias que  componen a la misma. De esta forma, el PSD nos aporta información acerca de qué frecuencias características de una serie de tiempo son las que contienen una mayor o menor cantidad de energía.","cell_type":"markdown"}
{"type":"cell","id":"2f8410","pos":7,"input":"# Plot EEG signal\nfig = plt.figure(figsize=(20, 5), dpi=100)\nplt.figure(1)\n\nplt.title('Electroencefalograma')\nplt.xlabel(r'tiempo (s)')\nplt.ylabel(r'voltaje ($\\mu$V)')\nplt.grid=True\n\n\nplt.plot(tiempo,eeg)\nplt.xlim(0,max(tiempo))\nplt.grid=True\n\nplt.show()\n","output":{"0":{"data":{"image/png":"07882386cf494860ad16c9bbc55499ff2d4eaf04"},"output_type":"execute_result","exec_count":4}},"cell_type":"code","exec_count":4}
{"type":"cell","id":"39ebe2","pos":0,"input":"# Tutorial 3-  Medidas de autocorrelación e introducción al análisis de Fourier\n### Noel Isaías Placencia-Díaz, Erin C. McKiernan, Marco Arieli Herrera-Valdez,\n### Facultad de Ciencias, UNAM\n\n","cell_type":"markdown"}
{"type":"cell","id":"4baee5","pos":13,"input":"A = (autocorr(eeg))","cell_type":"code","exec_count":7}
{"type":"cell","id":"53e48d","pos":5,"input":"##### Electoencefalograma\nPrimero vamos a extraer los datos y su escala de tiempo como lo hemos hecho anteriormente, en este caso, analizaremos datos correspondientes a un electroencefalograma (EEG):","cell_type":"markdown"}
{"type":"cell","id":"60abb6","pos":17,"input":"frq = np.fft.rfft(eeg) #Obtiene la transformada de Fourier discreta de 'eeg', a través de un algoritmo llamado fast fourier transform (fft)","cell_type":"code","exec_count":11}
{"type":"cell","id":"69e1e5","pos":10,"input":"Poncaire_Diagram(eeg,1)","output":{"0":{"data":{"image/png":"e5bed0b7f872bb13780780538961d44b8da82cae"},"output_type":"execute_result","exec_count":6}},"cell_type":"code","exec_count":6}
{"type":"cell","id":"7adabf","pos":1,"input":"%matplotlib inline","cell_type":"code","exec_count":1}
{"type":"cell","id":"818d32","pos":14,"input":"fig = plt.figure(figsize=(10, 3), dpi=200)\n\nax = fig.add_subplot(1, 1, 1)\nax.set_xlabel('tiempo [s]')\nax.set_ylabel('correlación')\nax.grid(True)\n#ax.set_xscale(10)\n\nax.plot(tiempo,A)\n\n","output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fd1036c6208>]"},"output_type":"execute_result","exec_count":9},"1":{"data":{"image/png":"9d95efb3e925dd7272001d40a8ca583ce100287b"},"output_type":"execute_result","exec_count":9}},"cell_type":"code","exec_count":9}
{"type":"cell","id":"a5e114","pos":12,"input":"def autocorr(x):\n    result = np.correlate(x, x, mode='full')\n    half=int(result.size/2)\n    return result[half:]/max(result[half:])","cell_type":"code","exec_count":4}
{"type":"cell","id":"ac8346","pos":22,"input":"fig = plt.figure()\n#Ejes y márgenes\nax= fig.add_axes([0,0,1,1])\n\nax.plot(freqs,power,linewidth=1.1,marker = \".\",markersize=1,\n       markerfacecolor=\"blue\")\n\nax.set_title('Espectro de Frecuencias')\nax.set_ylabel(\"[$\\mu V^{2}$]\")\nax.set_xlabel(\"Frecuencia [Hz]\")","output":{"0":{"data":{"text/plain":"Text(0.5,0,'Frecuencia [Hz]')"},"output_type":"execute_result","exec_count":14},"1":{"data":{"image/png":"73643659a32d94ab2bcaf353e89cf34cad7cf2f1"},"output_type":"execute_result","exec_count":14}},"cell_type":"code","exec_count":14}
{"type":"cell","id":"b1da94","pos":18,"input":"Ahora graficaremos el EEG en dominios del tiempo y de frecuencias:","cell_type":"markdown"}
{"type":"cell","id":"b5eecd","pos":4,"input":"<a id='introduction'></a>\n## 1. Introducción - Medidas de autocorrelación\nEn ocasiones los registros de datos fisiológicos pueden presentar patrones de repetición a lo largo del tiempo, ejemplos de esto los podemos encontrar en fenómenos como la fotosíntesis, el ritmo cardiaco, la respiración, la temperatura corporal, la actividad motora y cerebral, entre otros. A estos patrones se les conoce como $\\textit{ritmos fisiológicos}$ y estudiar la presencia o ausencia de ellos en ciertas funciones corporales, así como la modificación de estos mismos ante estímulos externos es de vital interés, pues los ritmos fisiológicos reflejan la actividad a gran escala de los mecanismos biológicos subyacentes en el organismo.\n\nUna forma de detectar la presencia de patrones repetitivos es a través de la autocorrelación. De forma intuitiva, la autocorrelación es una medida de $\\textit{cuánto se parece una señal a si misma}$, en este tutorial mediremos correlaciones a corto plazo temporal utilizando el $\\textit{Diagrama de dispersión de Poncairé}$ y correlaciones a largo plazo utilizando la $\\textit{función de autocorrelación}$.\n","cell_type":"markdown"}
{"type":"cell","id":"bd7c02","pos":9,"input":"def Poncaire_Diagram(signal,lag):\n\n    plt.figure(figsize=(3,3), dpi=200)\n    plt.figure(1)\n    \n    plt.plot(signal[:len(signal)-lag],signal[lag:],marker=\"+\",ms=.2,lw=0)\n\n    plt.axis('on')\n    plt.draw()\n    plt.show()","cell_type":"code","exec_count":5}
{"type":"cell","id":"ca0286","pos":21,"input":"power, freqs = matplotlib.mlab.psd(eeg, len(eeg), samp_rate)","cell_type":"code","exec_count":13}
{"type":"cell","id":"e000cf","pos":16,"input":"<a id='fourier_transf'></a>\n### 4.1 Transformada de Fourier\n\nLa transformada de Fourier nos permite observar una función exclusivamente en términos de sus frecuencias constitutivas, se dice que se esta es la representación de la función en el $\\textit{dominio de las frecuencias}$ (también espacio de fecuencias o espacio recíproco); por otro lado, se dice que la señal original, en términos de las variables tiempo-voltaje, está en el $\\textit{dominio del tiempo}$. \n\nAplicaremos la transformada de Fourier al los datos del EEG para obtener las frecuencias predominantes del registro.","cell_type":"markdown"}
{"type":"cell","id":"efcb62","pos":11,"input":"<a id='autocorr'></a>\n### 3. Función de autocorrelación\nEsta es la forma más comunmente utilizada para encontrar patrones de periodicidad en una señal, incluso resulta útil para detectar el periodo de repetición de la misma","cell_type":"markdown"}
{"type":"cell","id":"f43734","pos":8,"input":"<a id='poncaire'></a>\n### 2. Diagrama de dispersión de Poncairé\nEsta es una herramienta de análisis que nos permite encontrar correlaciones a corto plazo en una serie de tiempo, esta herramienta es usualmente utilizada en estudios series de tiempo fisiológicas (https://www.researchgate.net/publication/289971706_Poincare_plots_in_analysis_of_heart_rate_variability) y adquiere aún más utilidad cuando se conocen las periodicidades de la serie de tiempo analizada.\n\nEl diagrama de dispersión de Poncairé, tambien conocido como reconstrucción temporal del espacio fase, consiste en graficar la serie de tiempo estudiada contra si misma pero trasladada en un número determinado de puntos ($\\textit{lag}$).\n\nPara un $\\textit{lag}$ dado, si el diagrama se aproxima a una línea recta, podemos decir que los datos son muy similares, en cambio, si el diagrama se asemeja más a un círculo, podemos decir que no hay relación entre los datos, como es de imaginar, el punto medio entre estos dos comportamientos lo encontramos cuando el diagrama se asemeja más a una elipse.","cell_type":"markdown"}
{"type":"cell","id":"fb6592","pos":24,"input":"plt.plot(np.fft.rfft(A))","output":{"0":{"name":"stderr","output_type":"stream","text":"/ext/anaconda3/lib/python3.5/site-packages/numpy/core/numeric.py:531: ComplexWarning: Casting complex values to real discards the imaginary part\n  return array(a, dtype, copy=False, order=order)\n"},"1":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fd1036969e8>]"},"output_type":"execute_result","exec_count":15},"2":{"data":{"image/png":"2ccd3f3df48d1ffa074fccb3d6986d5d41c7df6d"},"output_type":"execute_result","exec_count":15}},"cell_type":"code","exec_count":15}
{"type":"cell","id":"fc8a04","pos":2,"input":"import numpy as np\nimport matplotlib.pyplot as plt","cell_type":"code","exec_count":2}
{"type":"file","last_load":1521139232455}
{"type":"settings","kernel":"anaconda3","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.4"}},"kernel_state":"idle","kernel_usage":{"cpu":0,"memory":86994944}}