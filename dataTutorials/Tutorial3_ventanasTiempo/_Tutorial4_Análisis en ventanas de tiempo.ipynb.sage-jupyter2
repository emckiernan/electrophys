{"exec_count":1,"start":1520381299395,"input":"%matplotlib inline","state":"done","pos":2,"cell_type":"code","type":"cell","end":1520381299426,"id":"20d429","kernel":"anaconda3"}
{"exec_count":2,"start":1520381300572,"input":"import matplotlib.pyplot as plt\nimport numpy as np\nimport wave\nimport pandas as pd\nimport scipy as sc","state":"done","pos":3,"cell_type":"code","type":"cell","end":1520381301433,"id":"1970d6","kernel":"anaconda3"}
{"exec_count":4,"start":1520381306479,"input":"def single_chan_wind(x,npoints):   #los parámetros de esta función son el registro a analizar y el número de puntos en cada ventana de tiempo.\n    \n    single_chan_wind = []\n    tot_points = len(x)            #Toma el número total de puntos de la serie\n    L = npoints\n    \n    nwind = tot_points//npoints    #Define el número de ventanas como la parte entera del cociente entre el número total de puntos y el número de                                         puntos por ventana de tiempo\n    \n    for h in range(0,nwind):\n        \n        t = x[h*L:L*(1+h)]         #Separa en ventanas de tiempo\n        single_chan_wind.append(t) #Coloca todas las ventanas de tiempo en un arreglo\n        \n    return(single_chan_wind)","state":"done","pos":6,"cell_type":"code","type":"cell","end":1520381306500,"id":"3d9333","kernel":"anaconda3"}
{"exec_count":5,"start":1520381308888,"input":"wind_waveData = single_chan_wind(waveData,50000)","scrolled":true,"state":"done","pos":8,"cell_type":"code","type":"cell","end":1520381308891,"id":"394ac2","kernel":"anaconda3"}
{"exec_count":8,"start":1520381314553,"input":"def variance_single_chan_wind(x,npoints):\n    \n    tot_points = len(x) #número total de puntos en el registro\n    nwind = tot_points//npoints #hace un cociente para obtener el número de ventanas de tiempo\n    wind_x = single_chan_wind(x,npoints) #Llama a la función que definimos anteriormente para reacomodar los datos en ventanas de tiempo\n    \n    v_single_chan_wind = [np.var(wind_x[w]) for w in range(0,nwind)] #Obtiene la varianza de cada una de las ventanas de tiempo anteriores.\n   \n    return(v_single_chan_wind)","scrolled":true,"state":"done","pos":12,"cell_type":"code","type":"cell","end":1520381314574,"id":"f95a50","kernel":"anaconda3"}
{"output":{"0":{"data":{"image/png":"d47e29c3cb8c539615aec2d4f551939821475213"},"metadata":{"image/png":{"height":462,"width":1623}}}},"exec_count":9,"start":1520381315671,"input":"fig = plt.figure(figsize=(20, 5), dpi=100)\nplt.figure(1)\n\nplt.title('Varianza del EMG en ventanas de tiempo')\nplt.xlabel(r'ventana de tiempo')\nplt.ylabel(r'varianza')\n\nplt.plot(variance_single_chan_wind(waveData,50000)/max(variance_single_chan_wind(waveData,50000)))\n\nplt.show()","state":"done","pos":13,"cell_type":"code","type":"cell","end":1520381318776,"id":"f63a10","kernel":"anaconda3"}
{"output":{"0":{"data":{"text/plain":"(55, 50000)"},"exec_count":6}},"exec_count":6,"start":1520381310111,"input":"#la función generó 55 ventanas, cada una con 100000 datos:\nnp.shape(wind_waveData)\n\n# NOTA: Si queremos acceder, por ejemplo, a la primer ventana de tiempo tecleamos: wind_waveData[0]","scrolled":true,"state":"done","pos":9,"cell_type":"code","type":"cell","end":1520381310163,"id":"66608d","kernel":"anaconda3"}
{"output":{"0":{"data":{"text/plain":"1.1337868480725624"},"exec_count":7}},"exec_count":7,"start":1520381311667,"input":"50000/sampleRate # Cada ventana de tiempo equivale a 1.1338 s aproximadamente","state":"done","pos":10,"cell_type":"code","type":"cell","end":1520381311732,"id":"1e4470","kernel":"anaconda3"}
{"output":{"0":{"text":"/ext/anaconda3/lib/python3.5/site-packages/ipykernel/__main__.py:3: DeprecationWarning: Numeric-style type codes are deprecated and will result in an error in the future.\n  app.launch_new_instance()\n","name":"stderr"}},"exec_count":3,"start":1520381301508,"input":"record1 = wave.open('Dec0.wav', 'r') \nframes = record1.readframes(-1) \nwaveData = np.fromstring(frames, 'Int16')\n\nnumChannels = record1.getnchannels() #número de canales\nsampleRate = record1.getframerate()  #frecuencia de muestreo\nsampleWidth = record1.getsampwidth()\nnumFrames = record1.getnframes() \n\ntiempo = np.arange(0,len(waveData))*(sampleRate)","state":"done","pos":4,"cell_type":"code","type":"cell","end":1520381301607,"id":"fe276e","kernel":"anaconda3"}
{"type":"cell","id":"2c45c4","pos":0.5,"input":"## Tabla de contenidos:\n\n[1. Introducción](#introduction)\n\n[2. Análisis en ventanas de tiempo](#timewindow)\n\n[3. Obtener la varianza en ventanas de tiempo](#variance)","cell_type":"markdown"}
{"type":"cell","id":"909824","pos":1,"input":"<a id='introduction'></a>\n## 1. Introducción - Series de tiempo no estacionarias \n\nUna serie de tiempo es llamada estacionaria si su distribución de probabilidad no cambia con respecto al tiempo, esto quiere decir que su valor promedio y su varianza no cambian con respecto al tiempo, esto hace a los procesos estacionarios (o series de tiempo estacionarias), fáciles de predecir, un ejemplo de una serie de tiempo estacionaria en fisiología es el ritmo cardiaco en reposo de un corazón sano.\n\nEn el análisis de datos fisiológicos es común encontrar series de tiempo no estacionarias, un ejemplo de esto lo podemos ver en la serie de tiempo del EMG que analizamos en el tutorial 2, recordemos que este registro fue obtenido colocando electrodos en el brazo de un voluntario, a quien se le pidió que levantara un peso mientras se realizaron las mediciones dela actividad muscular.","cell_type":"markdown"}
{"type":"cell","id":"95e909","pos":11,"input":"<a id='variance'></a>\n### 3. Calcular la varianza en cada una de las ventanas de tiempo\nLa siguiente función regresa un arreglo con la varianza calculada en ventadas de tiempo que tienen un tamaño predefinido.","cell_type":"markdown"}
{"type":"cell","id":"cff4be","pos":7,"input":"Aplicamos la función anterior a los datos, eligiendo ventanas de tiempo que contengan 50000 datos cada una:","cell_type":"markdown"}
{"type":"cell","id":"e89c4a","pos":5,"input":"<a id='timewindow'></a>\n### 2. Colocar los datos en ventanas de tiempo.\nUna forma de estudiar computacionalmente procesos no estacionarios es dividir el registro original en intervalos de tiempo regulares y medir las propiedades estadísticas de los datos en cada uno de estos segmentos, a cada uno de estos subregistros se les llama $\\textit{ventanas de tiempo}$.\n\nA continuación implementaremos una función que divide un registro en ventanas de tiempo:","cell_type":"markdown"}
{"type":"cell","id":"e90e41","pos":0,"input":"# Tutorial 3 -  Análisis en ventanas de tiempo\n### Noel Isaías Placencia-Díaz, Erin C. McKiernan, Marco Arieli Herrera-Valdez,\n### Facultad de Ciencias, UNAM\n\n\n","cell_type":"markdown"}
{"type":"cell","id":"f24fbb","pos":14,"input":"Podemos ver que la varianza de los datos dismunuye a medida que pasa el registro, ¿puedes explicar qué relación tiene esto con la actividad muscular que realizaba el voluntario?.","cell_type":"markdown"}
{"type":"file","last_load":1516043593457}
{"type":"settings","kernel":"anaconda3","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.4"}},"trust":true,"kernel_usage":{"cpu":0,"memory":86859776},"kernel_state":"idle"}